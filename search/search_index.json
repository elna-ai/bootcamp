{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rust bootcamp Day 1 What is rust Rust ecosystem Benefits of rust Rust playground Hello World Running locally Day 2 Comments Variables & Mutability Datatypes Functions Control flow Day 3 Slice type Stack & Heap Ownership References & Borrowing Day 4 Enum Struct Day 5 Packages & Crates Day 6 Collections Day 7 Traits Commandline Tests","title":"Rust bootcamp"},{"location":"#rust-bootcamp","text":"","title":"Rust bootcamp"},{"location":"#day-1","text":"What is rust Rust ecosystem Benefits of rust Rust playground Hello World Running locally","title":"Day 1"},{"location":"#day-2","text":"Comments Variables & Mutability Datatypes Functions Control flow","title":"Day 2"},{"location":"#day-3","text":"Slice type Stack & Heap Ownership References & Borrowing","title":"Day 3"},{"location":"#day-4","text":"Enum Struct","title":"Day 4"},{"location":"#day-5","text":"Packages & Crates","title":"Day 5"},{"location":"#day-6","text":"Collections","title":"Day 6"},{"location":"#day-7","text":"Traits Commandline Tests","title":"Day 7"},{"location":"day-1/getting-started/benefits/","text":"Benefits of Rust Rust has been Stack Overflow's most loved language for four years in a row LINK Rust is a systems programming language focused on safety, speed, and concurrency. Here are some of its benefits explained simply: Memory Safety : Rust ensures memory safety without needing a garbage collector by using ownership, borrowing, and lifetimes, which prevent common bugs like null pointer dereferencing and buffer overflows. Performance : Rust is designed for high performance, often matching or exceeding the speed of C and C++ while providing safer code. Concurrency : Rust makes it easier to write safe and concurrent code, reducing the chances of data races and other concurrency issues. Modern Syntax : Rust has a modern, expressive syntax that can make it easier to write and read complex code compared to some older languages. Community and Ecosystem : Rust has a growing community and a rich ecosystem of libraries and tools, making it easier to find resources and support for your projects. Cross-Platform : Rust supports cross-platform development, allowing you to write code that runs on various operating systems with minimal changes. Cargo : Rust's package manager and build system, Cargo, simplifies managing dependencies, building, and testing your projects. Comparison with Other Languages: C/C++ : While C and C++ offer low-level control and high performance, they lack the same level of memory safety guarantees. Rust provides similar performance with stronger safety guarantees. Python : Python is highly productive and easy to learn, but it is an interpreted language and generally slower than Rust. Rust is better suited for performance-critical applications. Java : Java offers strong memory management through garbage collection but can introduce runtime overhead. Rust\u2019s compile-time memory management avoids this overhead while providing similar safety features. Go : Go emphasizes simplicity and ease of use, especially for concurrent programming. However, Rust offers more control over system resources and memory safety without a garbage collector. Click to see the links [Why RUST is so popular](https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/)","title":"Benefits of Rust"},{"location":"day-1/getting-started/benefits/#benefits-of-rust","text":"Rust has been Stack Overflow's most loved language for four years in a row LINK Rust is a systems programming language focused on safety, speed, and concurrency. Here are some of its benefits explained simply: Memory Safety : Rust ensures memory safety without needing a garbage collector by using ownership, borrowing, and lifetimes, which prevent common bugs like null pointer dereferencing and buffer overflows. Performance : Rust is designed for high performance, often matching or exceeding the speed of C and C++ while providing safer code. Concurrency : Rust makes it easier to write safe and concurrent code, reducing the chances of data races and other concurrency issues. Modern Syntax : Rust has a modern, expressive syntax that can make it easier to write and read complex code compared to some older languages. Community and Ecosystem : Rust has a growing community and a rich ecosystem of libraries and tools, making it easier to find resources and support for your projects. Cross-Platform : Rust supports cross-platform development, allowing you to write code that runs on various operating systems with minimal changes. Cargo : Rust's package manager and build system, Cargo, simplifies managing dependencies, building, and testing your projects.","title":"Benefits of Rust"},{"location":"day-1/getting-started/benefits/#comparison-with-other-languages","text":"C/C++ : While C and C++ offer low-level control and high performance, they lack the same level of memory safety guarantees. Rust provides similar performance with stronger safety guarantees. Python : Python is highly productive and easy to learn, but it is an interpreted language and generally slower than Rust. Rust is better suited for performance-critical applications. Java : Java offers strong memory management through garbage collection but can introduce runtime overhead. Rust\u2019s compile-time memory management avoids this overhead while providing similar safety features. Go : Go emphasizes simplicity and ease of use, especially for concurrent programming. However, Rust offers more control over system resources and memory safety without a garbage collector. Click to see the links [Why RUST is so popular](https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/)","title":"Comparison with Other Languages:"},{"location":"day-1/getting-started/hello-world/","text":"Hello, World Let us jump into the simplest possible Rust program, a classic Hello World program: rust,editable fn main() { println!(\"Hello World!\"); } What you see: Functions are introduced with fn . Blocks are delimited by curly braces like in C and C++. The main function is the entry point of the program. Rust has hygienic macros, println! is an example of this. Rust strings are UTF-8 encoded and can contain any Unicode character. Click to see the links [RUST book](https://doc.rust-lang.org/book/ch01-02-hello-world.html)","title":"Hello, World"},{"location":"day-1/getting-started/hello-world/#hello-world","text":"Let us jump into the simplest possible Rust program, a classic Hello World program: rust,editable fn main() { println!(\"Hello World!\"); } What you see: Functions are introduced with fn . Blocks are delimited by curly braces like in C and C++. The main function is the entry point of the program. Rust has hygienic macros, println! is an example of this. Rust strings are UTF-8 encoded and can contain any Unicode character. Click to see the links [RUST book](https://doc.rust-lang.org/book/ch01-02-hello-world.html)","title":"Hello, World"},{"location":"day-1/getting-started/playground/","text":"Playground The Rust Playground provides an easy way to run short Rust programs, and is the basis for the examples and exercises in this course. Try running the \"hello-world\" program it starts with. It comes with a few handy features: Under \"Tools\", use the rustfmt option to format your code in the \"standard\" way. Rust has two main \"profiles\" for generating code: Debug (extra runtime checks, less optimization) and Release (fewer runtime checks, lots of optimization). These are accessible under \"Debug\" at the top. If you're interested, use \"ASM\" under \"...\" to see the generated assembly code.","title":"Playground"},{"location":"day-1/getting-started/playground/#playground","text":"The Rust Playground provides an easy way to run short Rust programs, and is the basis for the examples and exercises in this course. Try running the \"hello-world\" program it starts with. It comes with a few handy features: Under \"Tools\", use the rustfmt option to format your code in the \"standard\" way. Rust has two main \"profiles\" for generating code: Debug (extra runtime checks, less optimization) and Release (fewer runtime checks, lots of optimization). These are accessible under \"Debug\" at the top. If you're interested, use \"ASM\" under \"...\" to see the generated assembly code.","title":"Playground"},{"location":"day-1/getting-started/running-locally/","text":"Running Code Locally with Cargo If you want to experiment with the code on your own system, then you will need to first install Rust. Do this by following the instructions in the Rust Book . This should give you a working rustc and cargo . At the time of writing, the latest stable Rust release has these version numbers: % rustc --version rustc 1.69.0 (84c898d65 2023-04-16) % cargo --version cargo 1.69.0 (6e9a83356 2023-04-12) You can use any later version too since Rust maintains backwards compatibility. With this in place, follow these steps to build a Rust binary from one of the examples in this training: Click the \"Copy to clipboard\" button on the example you want to copy. Use cargo new exercise to create a new exercise/ directory for your code: shell $ cargo new exercise Created binary (application) `exercise` package Navigate into exercise/ and use cargo run to build and run your binary: shell $ cd exercise $ cargo run Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise) Finished dev [unoptimized + debuginfo] target(s) in 0.75s Running `target/debug/exercise` Hello, world! Replace the boiler-plate code in src/main.rs with your own code. For example, using the example on the previous page, make src/main.rs look like rust fn main() { println!(\"Edit me!\"); } Use cargo run to build and run your updated binary: shell $ cargo run Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise) Finished dev [unoptimized + debuginfo] target(s) in 0.24s Running `target/debug/exercise` Edit me! Use cargo check to quickly check your project for errors, use cargo build to compile it without running it. You will find the output in target/debug/ for a normal debug build. Use cargo build --release to produce an optimized release build in target/release/ . You can add dependencies for your project by editing Cargo.toml . When you run cargo commands, it will automatically download and compile missing dependencies for you.","title":"Running Code Locally with Cargo"},{"location":"day-1/getting-started/running-locally/#running-code-locally-with-cargo","text":"If you want to experiment with the code on your own system, then you will need to first install Rust. Do this by following the instructions in the Rust Book . This should give you a working rustc and cargo . At the time of writing, the latest stable Rust release has these version numbers: % rustc --version rustc 1.69.0 (84c898d65 2023-04-16) % cargo --version cargo 1.69.0 (6e9a83356 2023-04-12) You can use any later version too since Rust maintains backwards compatibility. With this in place, follow these steps to build a Rust binary from one of the examples in this training: Click the \"Copy to clipboard\" button on the example you want to copy. Use cargo new exercise to create a new exercise/ directory for your code: shell $ cargo new exercise Created binary (application) `exercise` package Navigate into exercise/ and use cargo run to build and run your binary: shell $ cd exercise $ cargo run Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise) Finished dev [unoptimized + debuginfo] target(s) in 0.75s Running `target/debug/exercise` Hello, world! Replace the boiler-plate code in src/main.rs with your own code. For example, using the example on the previous page, make src/main.rs look like rust fn main() { println!(\"Edit me!\"); } Use cargo run to build and run your updated binary: shell $ cargo run Compiling exercise v0.1.0 (/home/mgeisler/tmp/exercise) Finished dev [unoptimized + debuginfo] target(s) in 0.24s Running `target/debug/exercise` Edit me! Use cargo check to quickly check your project for errors, use cargo build to compile it without running it. You will find the output in target/debug/ for a normal debug build. Use cargo build --release to produce an optimized release build in target/release/ . You can add dependencies for your project by editing Cargo.toml . When you run cargo commands, it will automatically download and compile missing dependencies for you.","title":"Running Code Locally with Cargo"},{"location":"day-1/getting-started/rust-ecosystem/","text":"The Rust Ecosystem The Rust ecosystem consists of a number of tools, of which the main ones are: rustc : the Rust compiler which turns .rs files into binaries and other intermediate formats. cargo : the Rust dependency manager and build tool. Cargo knows how to download dependencies, usually hosted on https://crates.io , and it will pass them to rustc when building your project. Cargo also comes with a built-in test runner which is used to execute unit tests. rustup : the Rust toolchain installer and updater. This tool is used to install and update rustc and cargo when new versions of Rust are released. In addition, rustup can also download documentation for the standard library. You can have multiple versions of Rust installed at once and rustup will let you switch between them as needed.","title":"The Rust Ecosystem"},{"location":"day-1/getting-started/rust-ecosystem/#the-rust-ecosystem","text":"The Rust ecosystem consists of a number of tools, of which the main ones are: rustc : the Rust compiler which turns .rs files into binaries and other intermediate formats. cargo : the Rust dependency manager and build tool. Cargo knows how to download dependencies, usually hosted on https://crates.io , and it will pass them to rustc when building your project. Cargo also comes with a built-in test runner which is used to execute unit tests. rustup : the Rust toolchain installer and updater. This tool is used to install and update rustc and cargo when new versions of Rust are released. In addition, rustup can also download documentation for the standard library. You can have multiple versions of Rust installed at once and rustup will let you switch between them as needed.","title":"The Rust Ecosystem"},{"location":"day-1/getting-started/what-is-rust/","text":"What is Rust? Rust is a new programming language which had its 1.0 release in 2015 : Rust is a statically compiled language in a similar role as C++ rustc uses LLVM as its backend. Rust supports many platforms and architectures : x86, ARM, WebAssembly, ... Linux, Mac, Windows, ... Rust is used for a wide range of devices: firmware and boot loaders, smart displays, mobile phones, desktops, servers. Rust fits in the same area as C++: - High flexibility. - High level of control. - Can be scaled down to very constrained devices such as micro-controllers. - Has no runtime or garbage collection. - Focuses on reliability and safety without sacrificing performance.","title":"What is Rust?"},{"location":"day-1/getting-started/what-is-rust/#what-is-rust","text":"Rust is a new programming language which had its 1.0 release in 2015 : Rust is a statically compiled language in a similar role as C++ rustc uses LLVM as its backend. Rust supports many platforms and architectures : x86, ARM, WebAssembly, ... Linux, Mac, Windows, ... Rust is used for a wide range of devices: firmware and boot loaders, smart displays, mobile phones, desktops, servers. Rust fits in the same area as C++: - High flexibility. - High level of control. - Can be scaled down to very constrained devices such as micro-controllers. - Has no runtime or garbage collection. - Focuses on reliability and safety without sacrificing performance.","title":"What is Rust?"},{"location":"day-2/programming-concepts/comments/","text":"Comments in Rust In Rust, comments are used to provide additional explanation or context for code written by other developers. There are two types of comments: single-line comments and multi-line comments. Single-Line Comments Single-line comments start with // and continue until the end of the line. fn main() { let x = 5; // This is a single-line comment } Multi-Line Comments Multi-line comments start with // and can span multiple lines, ending when the next // or the end of the file is reached. fn main() { // This is a multi-line comment that spans two lines // Comment line two // Comment line three let x = 5; let y = 10; } Example Program with Comments Here's an example program that demonstrates how comments can be used to provide additional context: fn main() { // This function calculates the sum of two numbers fn add(a: i32, b: i32) -> i32 { // Calculate the sum of a and b return a + b; } let result = add(2, 3); println!(\"The result is: {}\", result); } In this example, the comments provide additional context about what each function does and how it works.","title":"Comments in Rust"},{"location":"day-2/programming-concepts/comments/#comments-in-rust","text":"In Rust, comments are used to provide additional explanation or context for code written by other developers. There are two types of comments: single-line comments and multi-line comments.","title":"Comments in Rust"},{"location":"day-2/programming-concepts/comments/#single-line-comments","text":"Single-line comments start with // and continue until the end of the line. fn main() { let x = 5; // This is a single-line comment }","title":"Single-Line Comments"},{"location":"day-2/programming-concepts/comments/#multi-line-comments","text":"Multi-line comments start with // and can span multiple lines, ending when the next // or the end of the file is reached. fn main() { // This is a multi-line comment that spans two lines // Comment line two // Comment line three let x = 5; let y = 10; }","title":"Multi-Line Comments"},{"location":"day-2/programming-concepts/comments/#example-program-with-comments","text":"Here's an example program that demonstrates how comments can be used to provide additional context: fn main() { // This function calculates the sum of two numbers fn add(a: i32, b: i32) -> i32 { // Calculate the sum of a and b return a + b; } let result = add(2, 3); println!(\"The result is: {}\", result); } In this example, the comments provide additional context about what each function does and how it works.","title":"Example Program with Comments"},{"location":"day-2/programming-concepts/control_flow/","text":"Control flow in rust If expressions In Rust, if expressions are used to branch code depending on conditions. The basic syntax is: fn main() { if condition { // code block for satisfied condition } else { // code block for unsatisfied condition } } Using if in a let statement You can also use if expressions on the right side of a let statement to assign the outcome to a variable: fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!(\"The value of number is: {number}\"); } Repetition with loops Rust provides three types of loops: loop , while , and for . Let's explore each: Repeating code with loop The loop keyword tells Rust to execute a block of code repeatedly until you explicitly tell it to stop. fn main() { loop { println!(\"again!\"); } } Conditional loops with while A while loop runs as long as the condition is true: fn main() { let mut number = 3; while number != 0 { println!(\"{number}!\"); number -= 1; } println!(\"LIFTOFF!!!\"); } Looping through a collection with for You can use for to loop over the elements of a collection, such as an array: fn main() { let a = [10, 20, 30, 40, 50]; let mut index = 0; while index < 5 { println!(\"the value is: {}\", a[index]); index += 1; } } Loop labels to disambiguate between multiple loops To disambiguate between multiple loops, you can use labels: fn main() { 'outer: for i in 1..3 { 'inner: for j in 1..3 { if i == 2 && j == 2 { break 'outer; } println!(\"{} * {} = {}\", i, j, i * j); } } }","title":"Control flow in rust"},{"location":"day-2/programming-concepts/control_flow/#control-flow-in-rust","text":"","title":"Control flow in rust"},{"location":"day-2/programming-concepts/control_flow/#if-expressions","text":"In Rust, if expressions are used to branch code depending on conditions. The basic syntax is: fn main() { if condition { // code block for satisfied condition } else { // code block for unsatisfied condition } }","title":"If expressions"},{"location":"day-2/programming-concepts/control_flow/#using-if-in-a-let-statement","text":"You can also use if expressions on the right side of a let statement to assign the outcome to a variable: fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!(\"The value of number is: {number}\"); }","title":"Using if in a let statement"},{"location":"day-2/programming-concepts/control_flow/#repetition-with-loops","text":"Rust provides three types of loops: loop , while , and for . Let's explore each:","title":"Repetition with loops"},{"location":"day-2/programming-concepts/control_flow/#repeating-code-with-loop","text":"The loop keyword tells Rust to execute a block of code repeatedly until you explicitly tell it to stop. fn main() { loop { println!(\"again!\"); } }","title":"Repeating code with loop"},{"location":"day-2/programming-concepts/control_flow/#conditional-loops-with-while","text":"A while loop runs as long as the condition is true: fn main() { let mut number = 3; while number != 0 { println!(\"{number}!\"); number -= 1; } println!(\"LIFTOFF!!!\"); }","title":"Conditional loops with while"},{"location":"day-2/programming-concepts/control_flow/#looping-through-a-collection-with-for","text":"You can use for to loop over the elements of a collection, such as an array: fn main() { let a = [10, 20, 30, 40, 50]; let mut index = 0; while index < 5 { println!(\"the value is: {}\", a[index]); index += 1; } }","title":"Looping through a collection with for"},{"location":"day-2/programming-concepts/control_flow/#loop-labels-to-disambiguate-between-multiple-loops","text":"To disambiguate between multiple loops, you can use labels: fn main() { 'outer: for i in 1..3 { 'inner: for j in 1..3 { if i == 2 && j == 2 { break 'outer; } println!(\"{} * {} = {}\", i, j, i * j); } } }","title":"Loop labels to disambiguate between multiple loops"},{"location":"day-2/programming-concepts/data-types/","text":"Data Types Rust is a statically typed language, which means that it must know the types of all variables at compile time. The compiler can usually infer what type we want to use based on the value and how we use it. Scalar Types A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let\u2019s jump into how they work in Rust. Here are some basic built-in types, and the syntax for literal values of each type. Types Literals Signed integers i8 , i16 , i32 , i64 , i128 , isize -10 , 0 , 1_000 , 123_i64 Unsigned integers u8 , u16 , u32 , u64 , u128 , usize 0 , 123 , 10_u16 Floating point numbers f32 , f64 3.14 , -10.0e20 , 2_f32 Unicode scalar values char 'a' , '\u03b1' , '\u221e' Booleans bool true , false The types have widths as follows: iN , uN , and fN are N bits wide, isize and usize are the width of a pointer, char is 32 bits wide, bool is 8 bits wide. fn main() { let x = 2.0; // f64 let y: f32 = 3.0; // f32 } fn main() { let t = true; let f: bool = false; // with explicit type annotation } Numeric Operations Rust supports the basic mathematical operations: addition, subtraction, multiplication, division, and remainder. fn main() { // addition let sum = 5 + 10; // subtraction let difference = 95.5 - 4.3; // multiplication let product = 4 * 30; // division let quotient = 56.7 / 32.2; let truncated = -5 / 3; // Results in -1 // remainder let remainder = 43 % 5; } Compound Types Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays. The Tuple Type: tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size. ```rust fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); } `` Destructuring of Tuple` ```rust fn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\"The value of y is: {y}\"); } ``` We can also access a tuple element directly by using a period (.) followed by the index of the value we want to access. For example: ```rust fn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2; } ``` Array Type Unlike a tuple, every element of an array must have the same type. Unlike arrays in some other languages, arrays in Rust have a fixed length. We write the values in an array as a comma-separated list inside square brackets : rust fn main() { let a = [1, 2, 3, 4, 5]; } An array is a single chunk of memory of a known, fixed size that can be allocated on the stack. You can access elements of an array using indexing, like this: rust fn main() { let a = [1, 2, 3, 4, 5]; let first = a[0]; let second = a[1]; } There are a few syntaxes which are not shown above: - All underscores in numbers can be left out, they are for legibility only. So `1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written as `123i64`.","title":"Data Types"},{"location":"day-2/programming-concepts/data-types/#data-types","text":"Rust is a statically typed language, which means that it must know the types of all variables at compile time. The compiler can usually infer what type we want to use based on the value and how we use it.","title":"Data Types"},{"location":"day-2/programming-concepts/data-types/#scalar-types","text":"A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let\u2019s jump into how they work in Rust. Here are some basic built-in types, and the syntax for literal values of each type. Types Literals Signed integers i8 , i16 , i32 , i64 , i128 , isize -10 , 0 , 1_000 , 123_i64 Unsigned integers u8 , u16 , u32 , u64 , u128 , usize 0 , 123 , 10_u16 Floating point numbers f32 , f64 3.14 , -10.0e20 , 2_f32 Unicode scalar values char 'a' , '\u03b1' , '\u221e' Booleans bool true , false The types have widths as follows: iN , uN , and fN are N bits wide, isize and usize are the width of a pointer, char is 32 bits wide, bool is 8 bits wide. fn main() { let x = 2.0; // f64 let y: f32 = 3.0; // f32 } fn main() { let t = true; let f: bool = false; // with explicit type annotation }","title":"Scalar Types"},{"location":"day-2/programming-concepts/data-types/#numeric-operations","text":"Rust supports the basic mathematical operations: addition, subtraction, multiplication, division, and remainder. fn main() { // addition let sum = 5 + 10; // subtraction let difference = 95.5 - 4.3; // multiplication let product = 4 * 30; // division let quotient = 56.7 / 32.2; let truncated = -5 / 3; // Results in -1 // remainder let remainder = 43 % 5; }","title":"Numeric Operations"},{"location":"day-2/programming-concepts/data-types/#compound-types","text":"Compound types can group multiple values into one type. Rust has two primitive compound types: tuples and arrays. The Tuple Type: tuple is a general way of grouping together a number of values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size. ```rust fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); } `` Destructuring of Tuple` ```rust fn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\"The value of y is: {y}\"); } ``` We can also access a tuple element directly by using a period (.) followed by the index of the value we want to access. For example: ```rust fn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2; } ``` Array Type Unlike a tuple, every element of an array must have the same type. Unlike arrays in some other languages, arrays in Rust have a fixed length. We write the values in an array as a comma-separated list inside square brackets : rust fn main() { let a = [1, 2, 3, 4, 5]; } An array is a single chunk of memory of a known, fixed size that can be allocated on the stack. You can access elements of an array using indexing, like this: rust fn main() { let a = [1, 2, 3, 4, 5]; let first = a[0]; let second = a[1]; } There are a few syntaxes which are not shown above: - All underscores in numbers can be left out, they are for legibility only. So `1_000` can be written as `1000` (or `10_00`), and `123_i64` can be written as `123i64`.","title":"Compound Types"},{"location":"day-2/programming-concepts/functions/","text":"Functions Introduction to Rust Functions Functions are a fundamental concept in Rust programming. They enable you to organize your code into reusable blocks of logic, making your programs more efficient and easier to maintain. fn main() { println!(\"Hello, world!\"); } Functions can take arguments, return values, and be reused throughout your program. The syntax for defining a function is as follows: fn function_name(parameters) -> return_type { // function body } In Rust, functions are executed in the order they are defined. When you call a function, the code within its block is executed until it reaches the end or returns a value. Rust also supports higher-order functions, which allow you to pass functions as arguments to other functions or return them from functions. This enables more complex and powerful programming patterns. Passing arguments to rust functions When declaring a function in Rust, you must specify the type of each parameter. For example: fn another_function(x: i32) { println!(\"The value of x is: {x}\"); } In this example, another_function takes one argument x which is specified as an i32. When calling a function with arguments, you must provide the correct types. For instance: fn main() { another_function(5); // Passes an i32 value to the function } In this example, we pass the value 5 to the another_function, which is an i32. The function will receive this value and use it as needed. Passing multiple parameters You can also define a function with multiple parameters by separating them with commas: fn print_labeled_measurement(value: i32, label: char) { println!(\"{}: {}\", label, value); } To call such a function, you would provide both values as arguments: fn main() { print_labeled_measurement(5, 'h'); // Passes an i32 and a char to the function } In this example, we pass the values 5 (an i32) and 'h' (a char) to the print_labeled_measurement function. This note will be useful for taking a live session on passing arguments to Rust functions. Functions with return values In Rust, functions can return values to the code that calls them. We don't name return values, but we must declare their type after an arrow (->). In Rust, the return value of a function is synonymous with the value of the final expression in the block of the function body. Here's an example: fn five() -> i32 { 5 } fn main() { let x = five(); } n this example, the five function returns an i32 value. The return value is implicit and is evaluated to be the result of the final expression in the function body. Returning early from a function You can also use the return keyword to explicitly return a value from a function: fn five() -> i32 { 5 // You can add more code here, but since we've already returned, // it won't be executed. return 5; } However, most functions implicitly return the result of the final expression in their body. This note will be used to take a live session.","title":"Functions"},{"location":"day-2/programming-concepts/functions/#functions","text":"","title":"Functions"},{"location":"day-2/programming-concepts/functions/#introduction-to-rust-functions","text":"Functions are a fundamental concept in Rust programming. They enable you to organize your code into reusable blocks of logic, making your programs more efficient and easier to maintain. fn main() { println!(\"Hello, world!\"); } Functions can take arguments, return values, and be reused throughout your program. The syntax for defining a function is as follows: fn function_name(parameters) -> return_type { // function body } In Rust, functions are executed in the order they are defined. When you call a function, the code within its block is executed until it reaches the end or returns a value. Rust also supports higher-order functions, which allow you to pass functions as arguments to other functions or return them from functions. This enables more complex and powerful programming patterns.","title":"Introduction to Rust Functions"},{"location":"day-2/programming-concepts/functions/#passing-arguments-to-rust-functions","text":"When declaring a function in Rust, you must specify the type of each parameter. For example: fn another_function(x: i32) { println!(\"The value of x is: {x}\"); } In this example, another_function takes one argument x which is specified as an i32. When calling a function with arguments, you must provide the correct types. For instance: fn main() { another_function(5); // Passes an i32 value to the function } In this example, we pass the value 5 to the another_function, which is an i32. The function will receive this value and use it as needed.","title":"Passing arguments to rust functions"},{"location":"day-2/programming-concepts/functions/#passing-multiple-parameters","text":"You can also define a function with multiple parameters by separating them with commas: fn print_labeled_measurement(value: i32, label: char) { println!(\"{}: {}\", label, value); } To call such a function, you would provide both values as arguments: fn main() { print_labeled_measurement(5, 'h'); // Passes an i32 and a char to the function } In this example, we pass the values 5 (an i32) and 'h' (a char) to the print_labeled_measurement function. This note will be useful for taking a live session on passing arguments to Rust functions.","title":"Passing multiple parameters"},{"location":"day-2/programming-concepts/functions/#functions-with-return-values","text":"In Rust, functions can return values to the code that calls them. We don't name return values, but we must declare their type after an arrow (->). In Rust, the return value of a function is synonymous with the value of the final expression in the block of the function body. Here's an example: fn five() -> i32 { 5 } fn main() { let x = five(); } n this example, the five function returns an i32 value. The return value is implicit and is evaluated to be the result of the final expression in the function body.","title":"Functions with return values"},{"location":"day-2/programming-concepts/functions/#returning-early-from-a-function","text":"You can also use the return keyword to explicitly return a value from a function: fn five() -> i32 { 5 // You can add more code here, but since we've already returned, // it won't be executed. return 5; } However, most functions implicitly return the result of the final expression in their body. This note will be used to take a live session.","title":"Returning early from a function"},{"location":"day-2/programming-concepts/variables-mutability/","text":"Variables Rust provides type safety via static typing. Variable bindings are made with let : fn main() { let x: i32 = 10; println!(\"x: {x}\"); // x = 20; // println!(\"x: {x}\"); } In RUST variables are immutable by default. When a variable is immutable, once a value is bound to a name, you can\u2019t change that value. However, you still have the option to make your variables mutable by adding mut in front of the variable name fn main() { let mut x: i32 = 10; println!(\"x: {x}\"); x = 20; println!(\"x: {x}\"); } Shadowing If you declare a new variable with the same name as a previous variable. Rustaceans say that the first variable is shadowed by the second, which means that the second variable is what the compiler will see when you use the name of the variable. ```rust fn main() { let x = 5; let x = x + 1; { let x = x * 2; println!(\"The value of x in the inner scope is: {x}\"); } println!(\"The value of x is: {x}\"); } ```","title":"Variables"},{"location":"day-2/programming-concepts/variables-mutability/#variables","text":"Rust provides type safety via static typing. Variable bindings are made with let : fn main() { let x: i32 = 10; println!(\"x: {x}\"); // x = 20; // println!(\"x: {x}\"); } In RUST variables are immutable by default. When a variable is immutable, once a value is bound to a name, you can\u2019t change that value. However, you still have the option to make your variables mutable by adding mut in front of the variable name fn main() { let mut x: i32 = 10; println!(\"x: {x}\"); x = 20; println!(\"x: {x}\"); }","title":"Variables"},{"location":"day-2/programming-concepts/variables-mutability/#shadowing","text":"If you declare a new variable with the same name as a previous variable. Rustaceans say that the first variable is shadowed by the second, which means that the second variable is what the compiler will see when you use the name of the variable. ```rust fn main() { let x = 5; let x = x + 1; { let x = x * 2; println!(\"The value of x in the inner scope is: {x}\"); } println!(\"The value of x is: {x}\"); } ```","title":"Shadowing"},{"location":"day-3/References_and_Borrowing/","text":"References and borrowing in rust In Rust, a reference is an alias for a value. References are immutable by default and can't be changed after they're created. There are two types of references: shared references ( & ) and mutable references ( &mut ). Mutable references A mutable reference allows you to modify the original data. Here's an example: let mut s = String::from(\"hello\"); let r3 = &mut s; // no problem println!(\"{r3}\"); In this example, s is a mutable string and r3 is a mutable reference to it. Dangling references Rust ensures that references will never be dangling references. If you try to create a dangling reference, the compiler will prevent it: fn dangle() -> &String { let s = String::from(\"hello\"); let r2 = &s; } // Error: cannot return a reference to a local data from `dangle` The rules of references The rules for combining mutable and immutable references are: A value can have at most one owner (mutable reference) at any given time. If you have a mutable reference to some data, you can't create another mutable reference to the same data until the first one goes out of scope. Here's an example that demonstrates these rules: fn main() { let mut s = String::from(\"hello\"); let r1 = &s; // no problem let r2 = &s; // no problem let r3 = &mut s; // BIG PROBLEM println!(\"{}, {}, and {}\", r1, r2, r3); } // Error: cannot borrow `s` as mutable because it is also borrowed as immutable In this example, the error message indicates that we can't create a new mutable reference ( r3 ) until the previous immutable references ( r1 and r2 ) go out of scope. To avoid these issues, you can use curly brackets to create a new scope: fn main() { let mut s = String::from(\"hello\"); { let r1 = &mut s; } // r1 goes out of scope here, so we can make a new reference with no problems. let r2 = &s; // no problem } In this example, r1 goes out of scope before we create the new mutable reference ( r2 ), allowing us to create multiple references without issues.","title":"References and borrowing in rust"},{"location":"day-3/References_and_Borrowing/#references-and-borrowing-in-rust","text":"In Rust, a reference is an alias for a value. References are immutable by default and can't be changed after they're created. There are two types of references: shared references ( & ) and mutable references ( &mut ).","title":"References and borrowing in rust"},{"location":"day-3/References_and_Borrowing/#mutable-references","text":"A mutable reference allows you to modify the original data. Here's an example: let mut s = String::from(\"hello\"); let r3 = &mut s; // no problem println!(\"{r3}\"); In this example, s is a mutable string and r3 is a mutable reference to it.","title":"Mutable references"},{"location":"day-3/References_and_Borrowing/#dangling-references","text":"Rust ensures that references will never be dangling references. If you try to create a dangling reference, the compiler will prevent it: fn dangle() -> &String { let s = String::from(\"hello\"); let r2 = &s; } // Error: cannot return a reference to a local data from `dangle`","title":"Dangling references"},{"location":"day-3/References_and_Borrowing/#the-rules-of-references","text":"The rules for combining mutable and immutable references are: A value can have at most one owner (mutable reference) at any given time. If you have a mutable reference to some data, you can't create another mutable reference to the same data until the first one goes out of scope. Here's an example that demonstrates these rules: fn main() { let mut s = String::from(\"hello\"); let r1 = &s; // no problem let r2 = &s; // no problem let r3 = &mut s; // BIG PROBLEM println!(\"{}, {}, and {}\", r1, r2, r3); } // Error: cannot borrow `s` as mutable because it is also borrowed as immutable In this example, the error message indicates that we can't create a new mutable reference ( r3 ) until the previous immutable references ( r1 and r2 ) go out of scope. To avoid these issues, you can use curly brackets to create a new scope: fn main() { let mut s = String::from(\"hello\"); { let r1 = &mut s; } // r1 goes out of scope here, so we can make a new reference with no problems. let r2 = &s; // no problem } In this example, r1 goes out of scope before we create the new mutable reference ( r2 ), allowing us to create multiple references without issues.","title":"The rules of references"},{"location":"day-3/ownership/","text":"Ownership in Rust What Is Ownership? Ownership is a concept in Rust that manages memory through a system of rules. The compiler checks these rules, ensuring the program won't compile if they're violated. This approach eliminates runtime errors related to memory management. Ownership Rules Ownership follows three main rules: Each value has an owner. There can be only one owner at a time. When the owner goes out of scope, the value will be dropped and freed. Variable Scope In Rust, variables have scope. When a variable goes out of scope, it is dropped, releasing any resources it held. This ensures memory safety by preventing dangling pointers. The String Type The String type in Rust represents a sequence of characters. It's implemented as a growable array on the heap, allowing for dynamic memory allocation and manipulation. Memory and Allocation Rust uses move semantics to transfer ownership of data between variables or functions. This ensures that data is properly managed and released when no longer needed. Variables and Data Interacting with Move When assigning a value to another variable using the = operator, Rust performs a move operation. This transfers ownership of the data from the original variable to the new one. let s = String::from(\"hello\"); // s owns the string let t = s; // s moves its ownership to t Variables and Data Interacting with Clone Some types, like String , implement the Clone trait. This allows for creating a copy of the data using the clone() method. use std::string::String; fn main() { let s = String::from(\"hello\"); // s owns the string let t = s.clone(); // s clones its ownership to t } Stack-Only Data: Copy Some types, like i32 , are stored on the stack and can be copied using the = operator. let x = 5; // x is a copy of 5 Ownership and Functions Ownership rules apply to functions in Rust. When calling a function, any variables passed as arguments will transfer ownership to the function. fn takes_ownership(some_integer: i32) { println!(\"{some_integer}\"); } let s = String::from(\"hello\"); // s owns the string takes_ownership(s); // s moves its ownership to the function Return Values and Scope Return values in Rust can transfer ownership. When a function returns a value, it will move its ownership to the caller. fn gives_ownership() -> String { String::from(\"hello\"); } let s = gives_ownership(); // gives_ownership moves its return value into s These notes provide an overview of ownership in Rust, including its rules, scope, and interactions with variables and functions.","title":"Ownership in Rust"},{"location":"day-3/ownership/#ownership-in-rust","text":"","title":"Ownership in Rust"},{"location":"day-3/ownership/#what-is-ownership","text":"Ownership is a concept in Rust that manages memory through a system of rules. The compiler checks these rules, ensuring the program won't compile if they're violated. This approach eliminates runtime errors related to memory management.","title":"What Is Ownership?"},{"location":"day-3/ownership/#ownership-rules","text":"Ownership follows three main rules: Each value has an owner. There can be only one owner at a time. When the owner goes out of scope, the value will be dropped and freed.","title":"Ownership Rules"},{"location":"day-3/ownership/#variable-scope","text":"In Rust, variables have scope. When a variable goes out of scope, it is dropped, releasing any resources it held. This ensures memory safety by preventing dangling pointers.","title":"Variable Scope"},{"location":"day-3/ownership/#the-string-type","text":"The String type in Rust represents a sequence of characters. It's implemented as a growable array on the heap, allowing for dynamic memory allocation and manipulation.","title":"The String Type"},{"location":"day-3/ownership/#memory-and-allocation","text":"Rust uses move semantics to transfer ownership of data between variables or functions. This ensures that data is properly managed and released when no longer needed.","title":"Memory and Allocation"},{"location":"day-3/ownership/#variables-and-data-interacting-with-move","text":"When assigning a value to another variable using the = operator, Rust performs a move operation. This transfers ownership of the data from the original variable to the new one. let s = String::from(\"hello\"); // s owns the string let t = s; // s moves its ownership to t","title":"Variables and Data Interacting with Move"},{"location":"day-3/ownership/#variables-and-data-interacting-with-clone","text":"Some types, like String , implement the Clone trait. This allows for creating a copy of the data using the clone() method. use std::string::String; fn main() { let s = String::from(\"hello\"); // s owns the string let t = s.clone(); // s clones its ownership to t }","title":"Variables and Data Interacting with Clone"},{"location":"day-3/ownership/#stack-only-data-copy","text":"Some types, like i32 , are stored on the stack and can be copied using the = operator. let x = 5; // x is a copy of 5","title":"Stack-Only Data: Copy"},{"location":"day-3/ownership/#ownership-and-functions","text":"Ownership rules apply to functions in Rust. When calling a function, any variables passed as arguments will transfer ownership to the function. fn takes_ownership(some_integer: i32) { println!(\"{some_integer}\"); } let s = String::from(\"hello\"); // s owns the string takes_ownership(s); // s moves its ownership to the function","title":"Ownership and Functions"},{"location":"day-3/ownership/#return-values-and-scope","text":"Return values in Rust can transfer ownership. When a function returns a value, it will move its ownership to the caller. fn gives_ownership() -> String { String::from(\"hello\"); } let s = gives_ownership(); // gives_ownership moves its return value into s These notes provide an overview of ownership in Rust, including its rules, scope, and interactions with variables and functions.","title":"Return Values and Scope"},{"location":"day-3/slice_type/","text":"The slice type in rust String slices In Rust, a string slice is a reference to a contiguous sequence of elements in a collection. It does not have ownership and allows you to reference part of a larger string without copying the entire string. Example: let s = \"hello\"; let hello = &s[0..5]; println!(\"{}\", hello); // Output: \"hello\" In this example, hello is a string slice that references the first 5 characters of the string s . String literals as slices String literals can be treated as slices. This means you can use the same syntax to create a slice from a string literal as you would for a regular string. Example: let hello = \"hello\"; let world = &hello[6..11]; println!(\"{}\", world); // Output: \"world\" In this example, world is a string slice that references the characters 6-10 of the string literal \"hello\" . Other slices Slices are not limited to strings. You can create slices for other collection types such as vectors and arrays. Example: let arr = [1, 2, 3, 4, 5]; let slice = &arr[1..3]; println!(\"{:?}\", slice); // Output: [2, 3] In this example, slice is a reference to the second and third elements of the array arr . Note that string slices must occur at valid UTF-8 character boundaries. Attempting to create a slice in the middle of a multibyte character will result in an error.","title":"The slice type in rust"},{"location":"day-3/slice_type/#the-slice-type-in-rust","text":"","title":"The slice type in rust"},{"location":"day-3/slice_type/#string-slices","text":"In Rust, a string slice is a reference to a contiguous sequence of elements in a collection. It does not have ownership and allows you to reference part of a larger string without copying the entire string. Example: let s = \"hello\"; let hello = &s[0..5]; println!(\"{}\", hello); // Output: \"hello\" In this example, hello is a string slice that references the first 5 characters of the string s .","title":"String slices"},{"location":"day-3/slice_type/#string-literals-as-slices","text":"String literals can be treated as slices. This means you can use the same syntax to create a slice from a string literal as you would for a regular string. Example: let hello = \"hello\"; let world = &hello[6..11]; println!(\"{}\", world); // Output: \"world\" In this example, world is a string slice that references the characters 6-10 of the string literal \"hello\" .","title":"String literals as slices"},{"location":"day-3/slice_type/#other-slices","text":"Slices are not limited to strings. You can create slices for other collection types such as vectors and arrays. Example: let arr = [1, 2, 3, 4, 5]; let slice = &arr[1..3]; println!(\"{:?}\", slice); // Output: [2, 3] In this example, slice is a reference to the second and third elements of the array arr . Note that string slices must occur at valid UTF-8 character boundaries. Attempting to create a slice in the middle of a multibyte character will result in an error.","title":"Other slices"},{"location":"day-3/stack-heap/","text":"Program Memory In Rust programming, memory can be categorized primarily into stack memory and heap memory, each serving different purposes and having different characteristics. Here\u2019s a breakdown of the different types of memory in Rust: 1. Stack Memory Characteristics: Continuous area of memory for local variables. Fast allocation and deallocation. Data is stored in a Last-In-First-Out (LIFO) manner. Limited in size. Suitable for data with a known, fixed size at compile time. Usage: Local variables. Function arguments. Return values. 2. Heap Memory Characteristics: Slower allocation and deallocation compared to the stack. Data can be of dynamic size. Larger in size than the stack. Suitable for data that needs to live beyond the scope of a function. Usage: Dynamic data structures like vectors, strings, and hash maps. Data that needs to be shared or transferred across different parts of a program. Examples: Stack Allocation: rust fn main() { let x = 5; let y = x; // Both x and y are on the stack } Heap Allocation: rust fn main() { let s = String::from(\"hello\"); // s is on the heap }","title":"Program Memory"},{"location":"day-3/stack-heap/#program-memory","text":"In Rust programming, memory can be categorized primarily into stack memory and heap memory, each serving different purposes and having different characteristics. Here\u2019s a breakdown of the different types of memory in Rust:","title":"Program Memory"},{"location":"day-3/stack-heap/#1-stack-memory","text":"Characteristics: Continuous area of memory for local variables. Fast allocation and deallocation. Data is stored in a Last-In-First-Out (LIFO) manner. Limited in size. Suitable for data with a known, fixed size at compile time. Usage: Local variables. Function arguments. Return values.","title":"1. Stack Memory"},{"location":"day-3/stack-heap/#2-heap-memory","text":"Characteristics: Slower allocation and deallocation compared to the stack. Data can be of dynamic size. Larger in size than the stack. Suitable for data that needs to live beyond the scope of a function. Usage: Dynamic data structures like vectors, strings, and hash maps. Data that needs to be shared or transferred across different parts of a program.","title":"2. Heap Memory"},{"location":"day-3/stack-heap/#examples","text":"Stack Allocation: rust fn main() { let x = 5; let y = x; // Both x and y are on the stack } Heap Allocation: rust fn main() { let s = String::from(\"hello\"); // s is on the heap }","title":"Examples:"},{"location":"day-4/enum/","text":"Enums and pattern matching in rust Defining an enum An enum (short for \"enumeration\") is a user-defined type that represents a set of named values. In Rust, you can define an enum using the enum keyword. Example: enum Coin { Penny, Nickel, Dime, Quarter(UsState), } Enum values An enum can have multiple values, each with its own unique name. These values are called \"variants\". In the example above, Penny , Nickel , and Dime are the variants of the Coin enum. The Option Enum and Its Advantages Over Null Values Rust's Option<T> enum is a special type that represents either Some value or None. This allows you to explicitly handle the absence of a value, rather than relying on null values. Using Option<T> can help prevent runtime errors and make your code more robust. Example: let maybe_int = Some(5); match maybe_int { Some(i) => println!(\"Value: {}\", i), None => println!(\"No value\"), } The match Control Flow Construct The match control flow construct is used to execute different blocks of code based on the value of an expression. In Rust, you can use match with enums and pattern matching to extract values from enum variants. Example: enum Coin { Penny, Nickel, Dime, Quarter(UsState), } let coin = Coin::Quarter(UsState::Alabama); match coin { Coin::Penny => println!(\"Penny!\"), Coin::Nickel => println!(\"Nickel!\"), Coin::Dime => println!(\"Dime!\"), Coin::Quarter(state) => println!(\"Quarter from {state:?}!\"), } Patterns that bind to values Patterns are used in match expressions to bind values to variables. You can use patterns like literals, identifiers, and tuple structs to match enum variants. Example: enum Coin { Penny, Nickel, Dime, Quarter(UsState), } let coin = Coin::Quarter(UsState::Alabama); match coin { Coin::Penny => println!(\"Penny!\"), x => println!(\"Other: {x:?}\"), // x binds to the value } Matching with Option You can use Option<T> in a match expression to handle the absence of a value. Example: let maybe_int = Some(5); match maybe_int { Some(i) => println!(\"Value: {}\", i), None => println!(\"No value\"), } Matches are exhaustive Rust's match expressions are exhaustive, meaning that every possible variant of an enum must be handled. If you don't handle all the variants, the compiler will error. Example: enum Coin { Penny, Nickel, Dime, } let coin = Coin::Quarter(UsState::Alabama); // Error: Quarter is not handled! match coin { Coin::Penny => println!(\"Penny!\"), Coin::Nickel => println!(\"Nickel!\"), _ => println!(\"Other\"), // Not exhaustive! } Catch-all Patterns and the _ Placeholder The _ placeholder can be used as a catch-all pattern to handle any variant that doesn't match the previous patterns. Example: enum Coin { Penny, Nickel, Dime, Quarter(UsState), } let coin = Coin::Quarter(UsState::Alabama); match coin { Coin::Penny => println!(\"Penny!\"), x => println!(\"Other: {x:?}\"), // x binds to the value } Concise control flow with if let The if let statement is a concise way to handle enums and pattern matching. It combines an if statement with a match expression. Example: enum Coin { Penny, Nickel, Dime, Quarter(UsState), } let coin = Coin::Quarter(UsState::Alabama); let mut count = 0; if let Coin::Quarter(state) = coin { println!(\"State quarter from {state:?}!\"); } else { count += 1; } Output: State quarter from Alabama!","title":"Enums and pattern matching in rust"},{"location":"day-4/enum/#enums-and-pattern-matching-in-rust","text":"","title":"Enums and pattern matching in rust"},{"location":"day-4/enum/#defining-an-enum","text":"An enum (short for \"enumeration\") is a user-defined type that represents a set of named values. In Rust, you can define an enum using the enum keyword. Example: enum Coin { Penny, Nickel, Dime, Quarter(UsState), }","title":"Defining an enum"},{"location":"day-4/enum/#enum-values","text":"An enum can have multiple values, each with its own unique name. These values are called \"variants\". In the example above, Penny , Nickel , and Dime are the variants of the Coin enum.","title":"Enum values"},{"location":"day-4/enum/#the-option-enum-and-its-advantages-over-null-values","text":"Rust's Option<T> enum is a special type that represents either Some value or None. This allows you to explicitly handle the absence of a value, rather than relying on null values. Using Option<T> can help prevent runtime errors and make your code more robust. Example: let maybe_int = Some(5); match maybe_int { Some(i) => println!(\"Value: {}\", i), None => println!(\"No value\"), }","title":"The Option Enum and Its Advantages Over Null Values"},{"location":"day-4/enum/#the-match-control-flow-construct","text":"The match control flow construct is used to execute different blocks of code based on the value of an expression. In Rust, you can use match with enums and pattern matching to extract values from enum variants. Example: enum Coin { Penny, Nickel, Dime, Quarter(UsState), } let coin = Coin::Quarter(UsState::Alabama); match coin { Coin::Penny => println!(\"Penny!\"), Coin::Nickel => println!(\"Nickel!\"), Coin::Dime => println!(\"Dime!\"), Coin::Quarter(state) => println!(\"Quarter from {state:?}!\"), }","title":"The match Control Flow Construct"},{"location":"day-4/enum/#patterns-that-bind-to-values","text":"Patterns are used in match expressions to bind values to variables. You can use patterns like literals, identifiers, and tuple structs to match enum variants. Example: enum Coin { Penny, Nickel, Dime, Quarter(UsState), } let coin = Coin::Quarter(UsState::Alabama); match coin { Coin::Penny => println!(\"Penny!\"), x => println!(\"Other: {x:?}\"), // x binds to the value }","title":"Patterns that bind to values"},{"location":"day-4/enum/#matching-with-option","text":"You can use Option<T> in a match expression to handle the absence of a value. Example: let maybe_int = Some(5); match maybe_int { Some(i) => println!(\"Value: {}\", i), None => println!(\"No value\"), }","title":"Matching with Option"},{"location":"day-4/enum/#matches-are-exhaustive","text":"Rust's match expressions are exhaustive, meaning that every possible variant of an enum must be handled. If you don't handle all the variants, the compiler will error. Example: enum Coin { Penny, Nickel, Dime, } let coin = Coin::Quarter(UsState::Alabama); // Error: Quarter is not handled! match coin { Coin::Penny => println!(\"Penny!\"), Coin::Nickel => println!(\"Nickel!\"), _ => println!(\"Other\"), // Not exhaustive! }","title":"Matches are exhaustive"},{"location":"day-4/enum/#catch-all-patterns-and-the-_-placeholder","text":"The _ placeholder can be used as a catch-all pattern to handle any variant that doesn't match the previous patterns. Example: enum Coin { Penny, Nickel, Dime, Quarter(UsState), } let coin = Coin::Quarter(UsState::Alabama); match coin { Coin::Penny => println!(\"Penny!\"), x => println!(\"Other: {x:?}\"), // x binds to the value }","title":"Catch-all Patterns and the _ Placeholder"},{"location":"day-4/enum/#concise-control-flow-with-if-let","text":"The if let statement is a concise way to handle enums and pattern matching. It combines an if statement with a match expression. Example: enum Coin { Penny, Nickel, Dime, Quarter(UsState), } let coin = Coin::Quarter(UsState::Alabama); let mut count = 0; if let Coin::Quarter(state) = coin { println!(\"State quarter from {state:?}!\"); } else { count += 1; } Output: State quarter from Alabama!","title":"Concise control flow with if let"},{"location":"day-4/struct/","text":"Defining and instantiating structs in rust Defining structs In Rust, a struct is a way to group related data together. To define a struct, you start with the struct keyword followed by the name of the struct. Inside the curly brackets, you specify the fields and their types. struct User { active: bool, username: String, email: String, sign_in_count: u64, } Instantiating structs To create an instance of a struct, you use the same name as the struct followed by curly brackets containing key-value pairs. The keys are the names of the fields and the values are the data to be stored in those fields. let user = User { active: true, username: \"john_doe\".to_string(), email: \"johndoe@example.com\".to_string(), sign_in_count: 10, }; Using field init shorthand Rust provides a shorthand way to initialize fields using the following syntax: fn build_user(email: String, username: String) -> User { User { active: true, username, email, sign_in_count: 1, } } Creating instances from other instances with struct update syntax You can create a new instance of a struct by updating an existing one using the following syntax: let mut user = User { active: true, username: String::from(\"john_doe\"), email: String::from(\"johndoe@example.com\"), sign_in_count: 10, }; let updated_user = User { ..user, email: String::from(\"new_email@example.com\"), }; Using tuple structs without named fields Tuple structs allow you to define a struct with unnamed fields. This is useful when you want to give the whole tuple a name and make it a different type from other tuples. struct Point(i32, i32); let point = Point(10, 20); Unit-like structs without any fields You can define a struct without any fields using the following syntax: struct AlwaysEqual; fn main() { let subject = AlwaysEqual; } Ownership of struct data In Rust, each instance of a struct owns its own data. This means that when you create an instance of a struct, you are responsible for managing the memory of its fields. For example: let user = User { active: true, username: \"john_doe\".to_string(), email: \"johndoe@example.com\".to_string(), sign_in_count: 10, }; In this example, user owns the data stored in its fields.","title":"Defining and instantiating structs in rust"},{"location":"day-4/struct/#defining-and-instantiating-structs-in-rust","text":"","title":"Defining and instantiating structs in rust"},{"location":"day-4/struct/#defining-structs","text":"In Rust, a struct is a way to group related data together. To define a struct, you start with the struct keyword followed by the name of the struct. Inside the curly brackets, you specify the fields and their types. struct User { active: bool, username: String, email: String, sign_in_count: u64, }","title":"Defining structs"},{"location":"day-4/struct/#instantiating-structs","text":"To create an instance of a struct, you use the same name as the struct followed by curly brackets containing key-value pairs. The keys are the names of the fields and the values are the data to be stored in those fields. let user = User { active: true, username: \"john_doe\".to_string(), email: \"johndoe@example.com\".to_string(), sign_in_count: 10, };","title":"Instantiating structs"},{"location":"day-4/struct/#using-field-init-shorthand","text":"Rust provides a shorthand way to initialize fields using the following syntax: fn build_user(email: String, username: String) -> User { User { active: true, username, email, sign_in_count: 1, } }","title":"Using field init shorthand"},{"location":"day-4/struct/#creating-instances-from-other-instances-with-struct-update-syntax","text":"You can create a new instance of a struct by updating an existing one using the following syntax: let mut user = User { active: true, username: String::from(\"john_doe\"), email: String::from(\"johndoe@example.com\"), sign_in_count: 10, }; let updated_user = User { ..user, email: String::from(\"new_email@example.com\"), };","title":"Creating instances from other instances with struct update syntax"},{"location":"day-4/struct/#using-tuple-structs-without-named-fields","text":"Tuple structs allow you to define a struct with unnamed fields. This is useful when you want to give the whole tuple a name and make it a different type from other tuples. struct Point(i32, i32); let point = Point(10, 20);","title":"Using tuple structs without named fields"},{"location":"day-4/struct/#unit-like-structs-without-any-fields","text":"You can define a struct without any fields using the following syntax: struct AlwaysEqual; fn main() { let subject = AlwaysEqual; }","title":"Unit-like structs without any fields"},{"location":"day-4/struct/#ownership-of-struct-data","text":"In Rust, each instance of a struct owns its own data. This means that when you create an instance of a struct, you are responsible for managing the memory of its fields. For example: let user = User { active: true, username: \"john_doe\".to_string(), email: \"johndoe@example.com\".to_string(), sign_in_count: 10, }; In this example, user owns the data stored in its fields.","title":"Ownership of struct data"},{"location":"day-5/packages_and_crates/","text":"Packages and Crates In Rust, packages and crates are fundamental concepts for organizing and distributing your code. Packages A package is a collection of related libraries, executables, or other assets that can be used together to build a larger project. Think of it as a directory containing multiple Rust files, along with their corresponding dependencies. Example: [package] name = \"my_package\" version = \"0.1.0\" [dependencies] log = \"0.4.14\" serde = \"1.0.126\" In this example, my_package is a package with two dependencies: log and serde . Crates A crate is a single library or executable that can be used in your project. Think of it as a single file containing code you want to use elsewhere. Example: use log::info; use serde::{Deserialize, Serialize}; #[derive(Debug, Serialize, Deserialize)] struct MyStruct { foo: String, } fn main() { info!(\"Hello from my crate!\"); } In this example, my_crate is a crate with a single executable that prints a message to the console. Benefits Organize your code into logical groups Share code between projects and teams Leverage existing libraries and dependencies Example Code Let's create a simple package and crate: [package] name = \"my_package\" version = \"0.1.0\" [dependencies] log = \"0.4.14\" use log::info; fn main() { info!(\"Hello from my crate!\"); } Output When you run the above code, you should see: INFO: my_crate: Hello from my crate! By using packages and crates, you can efficiently manage your Rust projects and share code with others.","title":"Packages and Crates"},{"location":"day-5/packages_and_crates/#packages-and-crates","text":"In Rust, packages and crates are fundamental concepts for organizing and distributing your code.","title":"Packages and Crates"},{"location":"day-5/packages_and_crates/#packages","text":"A package is a collection of related libraries, executables, or other assets that can be used together to build a larger project. Think of it as a directory containing multiple Rust files, along with their corresponding dependencies. Example: [package] name = \"my_package\" version = \"0.1.0\" [dependencies] log = \"0.4.14\" serde = \"1.0.126\" In this example, my_package is a package with two dependencies: log and serde .","title":"Packages"},{"location":"day-5/packages_and_crates/#crates","text":"A crate is a single library or executable that can be used in your project. Think of it as a single file containing code you want to use elsewhere. Example: use log::info; use serde::{Deserialize, Serialize}; #[derive(Debug, Serialize, Deserialize)] struct MyStruct { foo: String, } fn main() { info!(\"Hello from my crate!\"); } In this example, my_crate is a crate with a single executable that prints a message to the console.","title":"Crates"},{"location":"day-5/packages_and_crates/#benefits","text":"Organize your code into logical groups Share code between projects and teams Leverage existing libraries and dependencies Example Code Let's create a simple package and crate: [package] name = \"my_package\" version = \"0.1.0\" [dependencies] log = \"0.4.14\" use log::info; fn main() { info!(\"Hello from my crate!\"); } Output When you run the above code, you should see: INFO: my_crate: Hello from my crate! By using packages and crates, you can efficiently manage your Rust projects and share code with others.","title":"Benefits"},{"location":"day-6/collections/","text":"Common Collections in Rust Storing Lists of Values with Vectors Vectors are a fundamental data structure in Rust, allowing you to store a variable number of values next to each other. Unlike arrays, vectors can grow or shrink in size dynamically. Example Code: let mut scores = vec![10, 20, 30]; scores.push(40); println!(\"{:?}\", scores); // [10, 20, 30, 40] Storing UTF-8 Encoded Text with Strings In Rust, the String type is a collection of characters that can store more than just ASCII. This is due to Rust's support for UTF-8 encoding. Example Code: let mut s = String::new(); s.push_str(\"hello\"); println!(\"{}\", s); // \"hello\" Storing Keys with Associated Values in Hash Maps Hash maps, also known as hash tables or associative arrays, allow you to store keys associated with values. This structure is useful when you want to look up data based on a key rather than an index. Example Code: use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(\"Blue\", 10); scores.insert(\"Yellow\", 50); println!(\"{:?}\", scores); // {\"Blue\": 10, \"Yellow\": 50} In summary, Rust provides three fundamental collections for storing and managing data: vectors for lists of values, strings for UTF-8 encoded text, and hash maps for storing keys with associated values.","title":"Common Collections in Rust"},{"location":"day-6/collections/#common-collections-in-rust","text":"","title":"Common Collections in Rust"},{"location":"day-6/collections/#storing-lists-of-values-with-vectors","text":"Vectors are a fundamental data structure in Rust, allowing you to store a variable number of values next to each other. Unlike arrays, vectors can grow or shrink in size dynamically. Example Code: let mut scores = vec![10, 20, 30]; scores.push(40); println!(\"{:?}\", scores); // [10, 20, 30, 40]","title":"Storing Lists of Values with Vectors"},{"location":"day-6/collections/#storing-utf-8-encoded-text-with-strings","text":"In Rust, the String type is a collection of characters that can store more than just ASCII. This is due to Rust's support for UTF-8 encoding. Example Code: let mut s = String::new(); s.push_str(\"hello\"); println!(\"{}\", s); // \"hello\"","title":"Storing UTF-8 Encoded Text with Strings"},{"location":"day-6/collections/#storing-keys-with-associated-values-in-hash-maps","text":"Hash maps, also known as hash tables or associative arrays, allow you to store keys associated with values. This structure is useful when you want to look up data based on a key rather than an index. Example Code: use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(\"Blue\", 10); scores.insert(\"Yellow\", 50); println!(\"{:?}\", scores); // {\"Blue\": 10, \"Yellow\": 50} In summary, Rust provides three fundamental collections for storing and managing data: vectors for lists of values, strings for UTF-8 encoded text, and hash maps for storing keys with associated values.","title":"Storing Keys with Associated Values in Hash Maps"},{"location":"day-7/cli/","text":"Command line arguments Accepting command line arguments Rust provides a way to accept command-line arguments through the std::env::args function, which returns an iterator of command-line arguments passed to the program. Reading the argument values To read the values of command-line arguments, we can use the collect method on the iterator returned by std::env::args , and specify that we want a vector of strings. This will store all the command-line arguments in a single vector. Saving the argument values in variables Once we have collected the command-line arguments into a vector, we can access each argument individually using indexing or iteration. Here is an example code snippet: use std::env; fn main() { let args: Vec<String> = env::args().collect(); println!(\"{:?}\", args); } Output: $ cargo run -- hello world hello world [src/main.rs:4] args = [\"target/debug/minigrep\", \"hello\", \"world\"] Note that the first element in the vector is always the name of the executable, so you may want to skip this if you're not interested in it.","title":"Command line arguments"},{"location":"day-7/cli/#command-line-arguments","text":"","title":"Command line arguments"},{"location":"day-7/cli/#accepting-command-line-arguments","text":"Rust provides a way to accept command-line arguments through the std::env::args function, which returns an iterator of command-line arguments passed to the program.","title":"Accepting command line arguments"},{"location":"day-7/cli/#reading-the-argument-values","text":"To read the values of command-line arguments, we can use the collect method on the iterator returned by std::env::args , and specify that we want a vector of strings. This will store all the command-line arguments in a single vector.","title":"Reading the argument values"},{"location":"day-7/cli/#saving-the-argument-values-in-variables","text":"Once we have collected the command-line arguments into a vector, we can access each argument individually using indexing or iteration. Here is an example code snippet: use std::env; fn main() { let args: Vec<String> = env::args().collect(); println!(\"{:?}\", args); } Output: $ cargo run -- hello world hello world [src/main.rs:4] args = [\"target/debug/minigrep\", \"hello\", \"world\"] Note that the first element in the vector is always the name of the executable, so you may want to skip this if you're not interested in it.","title":"Saving the argument values in variables"},{"location":"day-7/test/","text":"Writing Automated Tests in Rust How to write tests In Rust, tests are functions that verify the expected behavior of non-test code. To create a test function, add the #[test] attribute before the fn declaration. #[cfg(test)] mod tests { // ... } The anatomy of a test function A typical test function performs three actions: Set up : Initialize any necessary data or state. Run the code under test : Execute the code being tested. Assert the results : Verify that the expected outcome occurs. Checking Results with assert! The assert! macro is used to verify that a condition is true. If the condition is false, the test will fail and print an error message. #[test] fn greeting_contains_name() { let result = greeting(\"Carol\"); assert!(result.contains(\"Carol\"), \"Greeting did not contain name, value was `{}`\", result); } Testing equality with assert_eq! and assert_ne! The assert_eq! macro checks that two values are equal. The assert_ne! macro checks that two values are not equal. #[test] fn adder_test() { let result = add(2, 3); assert_eq!(result, 5); } Adding custom failure messages When a test fails, it's helpful to provide a descriptive error message. You can create custom failure messages using the assert! macro. #[test] fn greeting_contains_name() { let result = greeting(\"Carol\"); assert!(result.contains(\"Carol\"), \"Greeting did not contain name, value was `{}`\", result); } Checking for panics with should_panic The should_panic attribute is used to test that a function panics under certain conditions. #[test] #[should_panic] fn create_guess_with_invalid_value() { Guess::new(101); } Example code and output Here's an example of testing the greeting function: pub fn greeting(name: &str) -> String { format!(\"Hello, {}!\", name) } #[cfg(test)] mod tests { use super::*; #[test] fn greeting_contains_name() { let result = greeting(\"Carol\"); assert!(result.contains(\"Carol\"), \"Greeting did not contain name, value was `{}`\", result); } } Output When you run the test with cargo test , you'll see the following output: running 1 test test tests::greeting_contains_name ... FAILED failures: tests::greeting_contains_name test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s This output indicates that the test has failed, and provides a descriptive error message. I hope this helps! Let me know if you have any questions or need further clarification.","title":"Writing Automated Tests in Rust"},{"location":"day-7/test/#writing-automated-tests-in-rust","text":"","title":"Writing Automated Tests in Rust"},{"location":"day-7/test/#how-to-write-tests","text":"In Rust, tests are functions that verify the expected behavior of non-test code. To create a test function, add the #[test] attribute before the fn declaration. #[cfg(test)] mod tests { // ... }","title":"How to write tests"},{"location":"day-7/test/#the-anatomy-of-a-test-function","text":"A typical test function performs three actions: Set up : Initialize any necessary data or state. Run the code under test : Execute the code being tested. Assert the results : Verify that the expected outcome occurs.","title":"The anatomy of a test function"},{"location":"day-7/test/#checking-results-with-assert","text":"The assert! macro is used to verify that a condition is true. If the condition is false, the test will fail and print an error message. #[test] fn greeting_contains_name() { let result = greeting(\"Carol\"); assert!(result.contains(\"Carol\"), \"Greeting did not contain name, value was `{}`\", result); }","title":"Checking Results with assert!"},{"location":"day-7/test/#testing-equality-with-assert_eq-and-assert_ne","text":"The assert_eq! macro checks that two values are equal. The assert_ne! macro checks that two values are not equal. #[test] fn adder_test() { let result = add(2, 3); assert_eq!(result, 5); }","title":"Testing equality with assert_eq! and assert_ne!"},{"location":"day-7/test/#adding-custom-failure-messages","text":"When a test fails, it's helpful to provide a descriptive error message. You can create custom failure messages using the assert! macro. #[test] fn greeting_contains_name() { let result = greeting(\"Carol\"); assert!(result.contains(\"Carol\"), \"Greeting did not contain name, value was `{}`\", result); }","title":"Adding custom failure messages"},{"location":"day-7/test/#checking-for-panics-with-should_panic","text":"The should_panic attribute is used to test that a function panics under certain conditions. #[test] #[should_panic] fn create_guess_with_invalid_value() { Guess::new(101); } Example code and output Here's an example of testing the greeting function: pub fn greeting(name: &str) -> String { format!(\"Hello, {}!\", name) } #[cfg(test)] mod tests { use super::*; #[test] fn greeting_contains_name() { let result = greeting(\"Carol\"); assert!(result.contains(\"Carol\"), \"Greeting did not contain name, value was `{}`\", result); } } Output When you run the test with cargo test , you'll see the following output: running 1 test test tests::greeting_contains_name ... FAILED failures: tests::greeting_contains_name test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s This output indicates that the test has failed, and provides a descriptive error message. I hope this helps! Let me know if you have any questions or need further clarification.","title":"Checking for panics with should_panic"},{"location":"day-7/traits/","text":"Traits: Defining shared behavior Traits in Rust allow us to define shared behavior for a particular type and ensure that any concrete type implementing this trait provides the required functionality. This helps reduce duplication and improves code maintainability. Defining a trait To define a trait, we use the pub trait keyword followed by the name of the trait. For example: pub trait Summary { fn summarize(&self) -> String; } In this example, we're defining a trait called Summary that requires any implementing type to provide an implementation for the summarize method. Implementing a trait on a type To implement a trait on a specific type, we use the impl keyword followed by the name of the trait. For example: pub struct NewsArticle { headline: String, author: String, location: String, } impl Summary for NewsArticle { fn summarize(&self) -> String { format!(\"{} - {}\", self.headline, self.author) } } In this example, we're implementing the Summary trait on the NewsArticle struct. The implementation provides a specific way to summarize a news article. Default implementations Traits can also provide default implementations for methods. This allows us to provide a fallback behavior if a type doesn't implement the method itself. For example: pub trait Summary { fn summarize(&self) -> String; } impl Summary for i32 { fn summarize(&self) -> String { \"No summary available\".to_string() } } In this example, we're providing a default implementation for the Summary trait on the i32 type. If any concrete type implementing Summary doesn't provide its own implementation, it will fall back to this default behavior. Traits as parameters Traits can also be used as parameters in functions and methods. This allows us to constrain the types that can be passed as arguments to a function or method. For example: pub fn notify(item: &impl Summary) { println!(\"{}\", item.summarize()); } In this example, we're defining a notify function that takes an item of type &impl Summary , which means it can take any type that implements the Summary trait. The function then calls the summarize method on the item and prints the result. Example Code: pub trait Summary { fn summarize(&self) -> String; } pub struct NewsArticle { headline: String, author: String, location: String, } impl Summary for NewsArticle { fn summarize(&self) -> String { format!(\"{} - {}\", self.headline, self.author) } } fn main() { let article = NewsArticle { headline: \"Rust Programming Language\".to_string(), author: \"The Author\".to_string(), location: \"Location\".to_string(), }; println!(\"{}\", article.summarize()); // Output: Rust Programming Language - The Author } Output: Rust Programming Language - The Author","title":"Traits: Defining shared behavior"},{"location":"day-7/traits/#traits-defining-shared-behavior","text":"Traits in Rust allow us to define shared behavior for a particular type and ensure that any concrete type implementing this trait provides the required functionality. This helps reduce duplication and improves code maintainability.","title":"Traits: Defining shared behavior"},{"location":"day-7/traits/#defining-a-trait","text":"To define a trait, we use the pub trait keyword followed by the name of the trait. For example: pub trait Summary { fn summarize(&self) -> String; } In this example, we're defining a trait called Summary that requires any implementing type to provide an implementation for the summarize method.","title":"Defining a trait"},{"location":"day-7/traits/#implementing-a-trait-on-a-type","text":"To implement a trait on a specific type, we use the impl keyword followed by the name of the trait. For example: pub struct NewsArticle { headline: String, author: String, location: String, } impl Summary for NewsArticle { fn summarize(&self) -> String { format!(\"{} - {}\", self.headline, self.author) } } In this example, we're implementing the Summary trait on the NewsArticle struct. The implementation provides a specific way to summarize a news article.","title":"Implementing a trait on a type"},{"location":"day-7/traits/#default-implementations","text":"Traits can also provide default implementations for methods. This allows us to provide a fallback behavior if a type doesn't implement the method itself. For example: pub trait Summary { fn summarize(&self) -> String; } impl Summary for i32 { fn summarize(&self) -> String { \"No summary available\".to_string() } } In this example, we're providing a default implementation for the Summary trait on the i32 type. If any concrete type implementing Summary doesn't provide its own implementation, it will fall back to this default behavior.","title":"Default implementations"},{"location":"day-7/traits/#traits-as-parameters","text":"Traits can also be used as parameters in functions and methods. This allows us to constrain the types that can be passed as arguments to a function or method. For example: pub fn notify(item: &impl Summary) { println!(\"{}\", item.summarize()); } In this example, we're defining a notify function that takes an item of type &impl Summary , which means it can take any type that implements the Summary trait. The function then calls the summarize method on the item and prints the result. Example Code: pub trait Summary { fn summarize(&self) -> String; } pub struct NewsArticle { headline: String, author: String, location: String, } impl Summary for NewsArticle { fn summarize(&self) -> String { format!(\"{} - {}\", self.headline, self.author) } } fn main() { let article = NewsArticle { headline: \"Rust Programming Language\".to_string(), author: \"The Author\".to_string(), location: \"Location\".to_string(), }; println!(\"{}\", article.summarize()); // Output: Rust Programming Language - The Author } Output: Rust Programming Language - The Author","title":"Traits as parameters"}]}